#
# Makefile
# Â© 2020 Vizio Services, All Rights Reserved
#
# This Makefile is the main Makefile for the entire platform repo.  A few things to note:
#    1. It uses an include paradigm rather than a recursive Makefile paradigm.  Components need
#		  only to include a very small, simple Makefile.include that defines (in the simplest case)
#       just a single variable.
#    2. Builds are done inside of a Docker container using bind mounts.  This allows proper
#       editing outside the container and change detection by the build system even inside the
#       container, but it does have the side effect of making all build products owned by root.
#       'sudo make clean' cleans them up.
#
# The Makefile.include files should have the following variables defined:
#    $(name)-snap      := (required) the name of the snap generated by Snapcraft
#    $(name)-type      := (required) the type of the snap package. Available options are : "app|content|fs|bsp"
#    $(name)-depend    := (optional) files or directories that are dependencies of the snap
#    $(name)-require   := (optional) ViziOS snaps that are required for building/deploying $(name)
#    $(name)-import    := (optional) import <pkg> into $(name) environment
#    $(name)-precmd    := (optional) exec user's cmd before snapcraft build
#    $(name)-postcmd   := (optional) exec user's cmd after snapcraft build
#    $(name)-cleancmd  := (optional) exec user's custom clean command
#    $(name)-env       := (optional) forward requested ENVs to snapcraft of the $(name)
#
# $(name) should be the name of the component, which should also be the name of the last directory
# in the path.  For example, the initramfs snap would have a Makefile.include that lives in the
# directory fs/initramfs and that contains lines like:
#    initramfs-snap    := initramfs_$(initramfs-version)_armhf.snap
#    initramfs-require := sysroot     # initramfs requires sysroot in order to build internal parts
#    initramfs-depend  := config/     # to recursively set config/ and its contents as a dependency
#    initramfs-depend  += tools/init  # to set the single file tools/init as a dependence
#
# Snaps are added to the Makefile by adding the paths to the Makefile.include to the variable
# $(SNAPS).  Every path listed here will define a target that can be invoked by calling 'make
# target'.  The target name is the component name which is the last part of the path, so for
# example, 'fs/initramfs' defines a target 'initramfs'.

# In addition to the Makefile.include mentioned previously, each directory listed here is also expected
# to have in it a snap/snapcraft.yaml file. Snapcraft will use this to build the snap.
# Also, to support the versioning of the snaps in a uniform way, each listed directory should contain
# a VERSION file with a dot-separated version number, and each snapcraft.yaml is expected to set
# its snap version to the value of the $SNAP_APP_VERSION environment variable.
# For example:
#    name: test-snap
#    adopt-info: snap-version
#    parts:
#      snap-version:
#        plugin: nil
#        source: .
#        override-pull: |
#          snapcraftctl set-version $SNAP_APP_VERSION
#
# So, TLDR, make a Makefile.include, a VERSION, a snap/snapcraft.yaml, and add the subdirectory path to the
# SNAPS variable in this Makefile.  That's it!
#

### SNAP DECLARATIONS
SNAPS := apps/alexa
SNAPS += apps/applicationcontroller
SNAPS += apps/btsound
SNAPS += apps/castmon
SNAPS += apps/castshell
SNAPS += apps/cirrentd
SNAPS += apps/dtvsvc
SNAPS += apps/errorcollector
SNAPS += apps/eventanalyzer
SNAPS += apps/fazer
SNAPS += apps/acr
SNAPS += apps/healthmon
SNAPS += apps/imm
SNAPS += apps/legacydeviceinfo
SNAPS += apps/loki
SNAPS += apps/mdnsd
SNAPS += apps/mediasdk
SNAPS += apps/memorymonitor
SNAPS += apps/networkmonitor
SNAPS += apps/perfetto
SNAPS += apps/platformorchestrator
SNAPS += apps/redwolf
SNAPS += apps/s3logger
SNAPS += apps/scpl
SNAPS += apps/sshd
SNAPS += apps/storaged
SNAPS += apps/systemregistry
SNAPS += apps/systemregistry-provisioner
SNAPS += apps/tools
SNAPS += apps/usb-mediatord
SNAPS += apps/viziosdkd
SNAPS += apps/vzairplayd
SNAPS += apps/progressiveplayer
SNAPS += apps/wsbridge
SNAPS += apps/wayland
SNAPS += apps/fallbackux
SNAPS += core/shared/sysroot
SNAPS += core/shared/sysroot-dlm
SNAPS += core/shared/sysroot-vizio
SNAPS += core/shared/sysrootllvm
SNAPS += core/sys/init
SNAPS += core/sys/initramfs
SNAPS += core/sys/kconfig
SNAPS += core/sys/policy
SNAPS += core/sys/rootfs
SNAPS += core/sys/virt-rootfs
SNAPS += core/tools/gcc
SNAPS += vendor/virt
SNAPS += vendor/mtk

###################### THE REST IS MAGIC.  NO EDITS NEEDED BELOW THIS LINE. ######################

### ENVIRONMENT SETUP

PROJECTDIR           := $(CURDIR)
OUTPUTDIR            := $(PROJECTDIR)/out
SUBMODULEDIR         := $(PROJECTDIR)/external
SUBMODULEGITDIR      := $(SUBMODULEDIR)/git
SNAPDIR              := $(OUTPUTDIR)/snaps
SNAPDBGDIR           := $(OUTPUTDIR)/dbg

BSPDIR               ?= $(SUBMODULEDIR)/apollo_archive
APOLLO_SUPPORT_DIR   := $(PROJECTDIR)/build/scripts/apolloSupport
TOOLCHAINDIR         ?= /opt/toolchain
DOCKER_BSPDIR        := /bsp
DOCKER_TOOLCHAINDIR  := /mtkoss

DEFAULT_MANIFEST     := $(SUBMODULEDIR)/platform-manifest/manifest.json
DISTRIBUTION_TYPE    ?= FW
DEBUG_ARCHIVE        ?= 1
NO_STRIP             ?= 0
DISTRIBUTION_TYPE_FMT:= flat

GN                   := $(PROJECTDIR)/build/gn_sources/out/gn
GN_OUTPUTDIR         := $(PROJECTDIR)/out/gn
DOCKER_HOME_DIR      := $(PROJECTDIR)/out/docker/home

$(shell mkdir -p $(OUTPUTDIR) $(GN_OUTPUTDIR) $(SUBMODULEDIR) $(BSPDIR) $(DOCKER_HOME_DIR))

UID := $(shell id -u)
GID := $(shell id -g)
DOCKER_USER_ARGS=-u ${UID}:${GID} \
                 -v /etc/passwd:/etc/passwd:ro \
                 -v /etc/group:/etc/group:ro \
                 -v ${DOCKER_HOME_DIR}:${HOME}

MAKEFLAGS += r

CONTAINER_RUNNER ?= main

ifeq (main, $(CONTAINER_RUNNER))
ifeq (,$(NO_TTY))
DOCKER_TTY=t
endif
endif

# Supported SoC-s.


# MTK 2019
SOC_GROUP_MTK19    := mtk5581
# Note: 2019 doesn't separated into x17 mtk5597 x18 MTK5597EM in platform
SOC_GROUP_MTK19    += mtk5597

# MTK 2020
SOC_GROUP_MTK20    := mtk5583
SOC_GROUP_MTK20    += mtk5691
SOC_GROUP_MTK20    += mtk5695
SOC_GROUP_MTK20    += mtk5695l
SOC_GROUP_MTK20    += mtk5695s

# MTK 2024
SOC_GROUP_MTK24    := mtk5586

SOC_GROUP_MTK20_24 := $(SOC_GROUP_MTK20) $(SOC_GROUP_MTK24)

# Novatek
SOC_GROUP_NVT      := nt72690

#qemu
SOC_GROUP_QEMU     := virt

KNOWN_TARGETS := $(SOC_GROUP_MTK19)
KNOWN_TARGETS += $(SOC_GROUP_MTK20)
KNOWN_TARGETS += $(SOC_GROUP_MTK24)
KNOWN_TARGETS += $(SOC_GROUP_NVT)
KNOWN_TARGETS += $(SOC_GROUP_QEMU)

KNOWN_RELEASE_TYPES := prod
KNOWN_RELEASE_TYPES += qa
KNOWN_RELEASE_TYPES += dev

### MAKE-RELATED HELPERS FOR USE IN RECIPES

BLUE   := $(shell printf "\033[1;34m")
YELLOW := $(shell printf "\033[1;33m")
GREEN  := $(shell printf "\033[1;32m")
RED    := $(shell printf "\033[1;31m")
BOLD   := $(shell printf "\033[0;1m")
NORMAL := $(shell printf "\033[0m")

VERBOSE ?= async

ifeq (1,$(VERBOSE))
$(info $(YELLOW)Deprecated verbose option. Use the new VERBOSE sync,async,quiet $(NORMAL))
override VERBOSE := sync
endif

ifeq (,$(filter $(VERBOSE),async sync quiet))
$(info $(RED)Unsupported VERBOSE=$(VERBOSE) option. Use VERBOSE sync,async,quiet $(NORMAL))
false
endif

ifneq (,$(filter $(VERBOSE),async sync))
	NINJA_VERBOSE = --verbose
	GN_SCRIPTS_VERBOSE = /dev/stdout
else ifeq ($(VERBOSE),quiet)
	GN_SCRIPTS_VERBOSE = /dev/null
	DOCKER_VERBOSE=-q
endif

now         = date +'%s'
start       = $(OUTPUTDIR)/.$(notdir $@)-start
elapsedTime = $$(date -ud @$$(($$($(now))-$$(cat "$(start)"))) +"%Hh:%Mm:%Ss")
startTiming = printf "$(BLUE)Running recipe: $(notdir $@) ... $(NORMAL)\n" && $(now) > "$(start)"
stopTiming  = printf "$(BLUE)completed in $(GREEN)$(elapsedTime)$(NORMAL)\n" && rm "$(start)"
writeTarget = $(if $(TARGET), echo $(TARGET) > "$(SETUP_TARGET)", echo default > "$(SETUP_TARGET)" )
### SANITY CHECKS

ifneq (1,$(shell jq --version > /dev/null 2>&1 && echo 1))
$(error $(RED)Please install jq! $(BOLD)sudo apt-get install jq$(NORMAL))
endif
ifneq (1,$(shell python3 --version > /dev/null 2>&1 && echo 1))
$(error $(RED)Please install python3! $(BOLD)sudo apt-get install python3 python$(NORMAL))
endif
ifneq (1,$(shell ninja --version > /dev/null 2>&1 && echo 1))
$(error $(RED)Please install ninja-build! $(BOLD)sudo apt-get install ninja-build$(NORMAL))
endif

ifneq (,$(TARGET))
ifeq (,$(filter $(KNOWN_TARGETS),$(TARGET)))
$(error $(RED)'TARGET' must be one of: $(BOLD)$(KNOWN_TARGETS)$(NORMAL))
endif

ifneq (,$(filter $(SOC_GROUP_MTK19),$(TARGET)))
SOC_GROUP := MTK19
else ifneq (,$(filter $(SOC_GROUP_MTK20),$(TARGET)))
SOC_GROUP := MTK20
else ifneq (,$(filter $(SOC_GROUP_MTK24),$(TARGET)))
SOC_GROUP := MTK24
else ifneq (,$(filter $(SOC_GROUP_NVT),$(TARGET)))
SOC_GROUP := NVT
else ifneq (,$(filter $(SOC_GROUP_QEMU),$(TARGET)))
SOC_GROUP := QEMU
else
$(error $(RED)'TARGET' doesn\'t belong to any SOC_GROUP$(NORMAL))
endif
endif

ifneq (,$(build_release))
ifeq (,$(filter $(KNOWN_RELEASE_TYPES),$(build_release)))
$(error $(RED)'build_release' must be one of: $(BOLD)$(KNOWN_RELEASE_TYPES)$(NORMAL))
endif
else
build_release=dev
endif

### DEFINES FOR BUILDING A SINGLE PART OF A SNAPCRAFT SNAP OR A RELEASE SNAP VERSION
SNAPCRAFT_OPS  := pull build stage prime clean
POSSIBLE_PARTS  = $(foreach snap,$(SNAPS),$(foreach op,$(SNAPCRAFT_OPS),$(notdir $(snap)).%.$(op)))
RELEASE_SNAPS := $(foreach snap,$(SNAPS),$(if $(findstring release_action,$(shell cat $(snap)/BUILD.gn)), release-$(notdir $(snap)) ))

### DEFAULT TARGET

.PHONY: default
default: help

.PHONY: need_target
need_target:
	@if [ -z "$(TARGET)" ]; then \
		printf "$(RED)ERROR: \"TARGET\" must be defined.$(NORMAL)\n" && false; \
	fi

# Get the default manifest from github if one has not been specified
ifndef MANIFEST

MANIFEST             := $(DEFAULT_MANIFEST)
MANIFEST_BRANCH       = $(shell cd $(dir $(DEFAULT_MANIFEST)) && git rev-parse --abbrev-ref HEAD)
.PHONY: get_manifest
get_manifest:
	@$(startTiming)
	@$(MANIFEST_HANDLER) --verbose $(VERBOSE) --get_manifest --manifest_id $(platform-manifest)
	@$(stopTiming)
setup: get_manifest $(GN) run_gn

ifeq (,$(ONLINE_MODE))
build_docker: get_manifest
endif

else
setup: $(GN) run_gn
MANIFEST_BRANCH    = custom
ifneq (,$(platform-manifest))
$(error $(RED)You are not allowed to define $(BOLD)MANIFEST$(RED) and $(BOLD)platform-manifest$(RED) simultaneously$(NORMAL))
endif

ifneq ($(shell jq -r '.base | select (.!=null)' $(MANIFEST)),)
$(error $(RED)In the current stage we are not supporting user manifest with base tag$(NORMAL))
endif

endif

CURRENT_BRANCH       := $(shell git rev-parse --abbrev-ref HEAD)
FORMAT_BRANCH         = $(subst /,-,$(CURRENT_BRANCH))
PLATFORM_BRANCH      ?= $(CURRENT_BRANCH)

CALCULATE_VERSION_SCRIPT = build/gn/utils/calculate_release_tarballs_name.sh
release_names = $(shell $(CALCULATE_VERSION_SCRIPT) --root=$(CURDIR) --dmanifest=$(DEFAULT_MANIFEST) \
                                                    --manifest=$(MANIFEST) --dtype=$(DISTRIBUTION_TYPE) \
                                                    --target=$(TARGET))

DOCKER_DIR           := build/docker
$(shell mkdir -p $(DOCKER_DIR))

ifeq (, $(ONLINE_MODE))
DOCKER_ID            := $(DOCKER_DIR)/id.docker.v2.$(FORMAT_BRANCH)
DOCKER_TAG           := artifactory.vizio.com/vizio-dallas-docker-images/platform_v2:$(FORMAT_BRANCH)
else
DOCKER_ID            := $(DOCKER_DIR)/id.docker.v2.$(CONTAINER_RUNNER)
DOCKER_TAG           := artifactory.vizio.com/vizio-dallas-docker-images/platform_v2:$(CONTAINER_RUNNER)
endif

DOCKER_TOOLCHAIN_TAG := platform_vztoolchain_v2
DOCKER_BASE_TAG      := platform_base_ninja_clean
DOCKER_FILE          := $(DOCKER_DIR)/Dockerfile
DOCKER_HANDLER       := build/scripts/buildsystem/DockerHandler.py
ifeq (github, $(CONTAINER_RUNNER))
DOCKER_FILE           = $(DOCKER_DIR)/Dockerfile.$(CONTAINER_RUNNER)
endif

.PHONY: need_manifest
need_manifest:
	@if ! [ -f $(MANIFEST) ]; then \
		printf "$(RED)ERROR: file manifest must be exist. Run $(BOLD)make setup$(RED) before building image$(NORMAL)\n" && false; \
	fi

CACHE_SUPPORT_DIR    := $(PROJECTDIR)/build/scripts/cacheSupport
CACHE_HANDLER        := $(CACHE_SUPPORT_DIR)/cacheHandler.sh
CACHE_APPS           := ""
CACHE_BRANCH         ?= ""
CACHE_CONFIG         ?= ""
CACHE                ?= 0

# Clone all repos specified in the manifest, and update to the proper versions.
MANIFEST_HANDLER       := build/scripts/buildsystem/BuildManager.py
CHECKOUT_JSON_HANDLER  := build/scripts/buildsystem/CheckoutJSON.py
APOLLO_HANDLER         := $(APOLLO_SUPPORT_DIR)/apolloHandler.sh
GN_INSTALLER           := build/gn/install_gn.sh
FORMAT_SCRIPT          := build/gn/format.sh
SETUP_HOST_ENV         := build/host/setup_environment.sh
HOST                   ?= 0


platform ?= ""
platform-manifest ?= $(CURRENT_BRANCH)

OUTPUTJSON := $(OUTPUTDIR)/checkout.json
JSON_RESPONSE ?= 0

MTK_BRANCH ?= ""
MTK_CONFIG ?= ""
MTK_TARGET ?= ""
REMOTE_SERVER ?= ""

ifneq (,$(filter $(MAKECMDGOALS),image release version-string release-rootfs))
PBRANCH_MBRANCH  := $(PLATFORM_BRANCH):$(MANIFEST_BRANCH)
endif

SETUP_VAR=JSON_RESPONSE=$(JSON_RESPONSE) platform=$(platform) PLATFORM_ROOT=$(PROJECTDIR)

reset-mtk:
	@$(startTiming)
	@$(APOLLO_HANDLER) -o reset -c $(MTK_CONFIG)
	@$(stopTiming)

list-mtk:
	@$(startTiming)
	@$(APOLLO_HANDLER) -o list -b $(MTK_BRANCH) -c $(MTK_CONFIG)
	@$(stopTiming)

sync-mtk:
	@$(startTiming)
	@$(APOLLO_HANDLER) -o sync -c $(MTK_CONFIG)
	@$(stopTiming)

setup-mtk:
	@$(startTiming)
	@$(APOLLO_HANDLER) -o setup -t $(MTK_TARGET) -b $(MTK_BRANCH) -c $(MTK_CONFIG) -r $(REMOTE_SERVER)
	@$(stopTiming)

setup-%: setup;

setup:
	@$(startTiming)
	@MANIFEST="$(realpath $(MANIFEST))"
	@$(SETUP_VAR) ninja -C $(PROJECTDIR)/out/gn $(GOAL) $(NINJA_VERBOSE)
	@$(writeTarget)
	@$(stopTiming)

setup-docker: need_manifest
	@$(startTiming)
	@if ! [ -f $(DOCKER_FILE) ]; then \
		rm -rf $(DOCKER_DIR); \
	fi
	@MANIFEST="$(realpath $(MANIFEST))"
	@$(MANIFEST_HANDLER) --manifest $(MANIFEST) --snap docker --platform_id $(platform) --target $(TARGET) --verbose $(VERBOSE)
	@$(stopTiming)

### Debug symbols tarball target
CONFIG_FILE            = $(PROJECTDIR)/build/scripts/cacheSupport/config/cache_config.json
DEBUG_ARCHIVE_HANDLER  = $(PROJECTDIR)/build/scripts/buildsystem/DebugArchive.py
TARGET                ?= $(shell echo $(VIZIOS_VERSION) | cut -d- -f1)
FW_VERSION            ?=''

ifeq (,$(filter $(TARGET),$(shell cat $(CONFIG_FILE) | jq -r '.supported_target | .[]')))
    $(info $(YELLOW)Debug symbols for this target is not supported$(NORMAL)\n)
endif
### VIZIOS_VERSION must be set manually in format : mtk5583-1.3.791.575.1-16210ca-e46f5a5
.PHONY: get-debug
get-debug:
	@$(DEBUG_ARCHIVE_HANDLER) --version $(VIZIOS_VERSION) --distribution_type $(DISTRIBUTION_TYPE) --target $(TARGET) --fw_version $(FW_VERSION) --branch $(CACHE_BRANCH) ;

install_gn $(GN): $(GN_INSTALLER);
	@printf "$(YELLOW)Target need gn package, it will be installed automatically$(NORMAL)\n"
	@$(GN_INSTALLER)

# You need to be careful with this flag, when it is active
# ninja doesn't check timestamps, only existing of snap files in 'out' directory
ifeq (1, $(CACHE))
NINJA_SKIP_CHECK=--nochecktime
endif

GN_ARGS=--args="GOAL=\"$(GOAL)\" \
				TARGET=\"$(TARGET)\" \
				SOC_GROUP=\"$(SOC_GROUP)\" \
				VERBOSE=\"$(VERBOSE)\" \
				BSP=\"$(BSP)\" \
				BSPDIR=\"$(BSPDIR)\" \
				MANIFEST=\"$(MANIFEST)\" \
				POSSIBLE_PARTS=\"$(possible_parts)\" \
				SNAPS=\"$(SNAPS)\" \
				VIRT_SNAPS=\"$(VIRT_SNAPS)\" \
				DOCKER_BSPDIR=\"$(DOCKER_BSPDIR)\" \
				DISTRIBUTION_TYPE=\"$(DISTRIBUTION_TYPE)\" \
				DISTRIBUTION_TYPE_FMT=\"$(DISTRIBUTION_TYPE_FMT)\" \
				PBRANCH_MBRANCH=\"$(PBRANCH_MBRANCH)\""

GN_GEN_DIR = out/gn/obj

# Run almost all targets inside a Docker container using a ViziOS build image.

CURRENT_BUILD_ENV_VAR := HOST=$(HOST) \
						DEBUG_ARCHIVE=$(DEBUG_ARCHIVE) NO_STRIP=$(NO_STRIP) \
						build_release=$(build_release) \
						GN_SCRIPTS_VERBOSE=$(GN_SCRIPTS_VERBOSE)

ifneq (1,$(HOST))
RUN_BUILD = run_docker
CLEAN = clean_docker_mode
CURRENT_BUILD_ENV_VAR += PLATFORM_ROOT=/platform
else
RUN_BUILD = run_host
CLEAN = clean_host_mode
host_environment_variables=$(shell $(SETUP_HOST_ENV) --PLATFORM_ROOT=$(CURDIR) --set_env_var)
CURRENT_BUILD_ENV_VAR += $(host_environment_variables)
endif

ALL_TARGETS := image image-virt $(notdir $(SNAPS)) version-string test build-rootfs

$(ALL_TARGETS): $(RUN_BUILD)
$(POSSIBLE_PARTS): $(RUN_BUILD);
$(RELEASE_SNAPS): $(RUN_BUILD);

# Helper variables for the Snapcraft build recipe
targetParts    = $(if $(findstring $(SNAPDIR),$(MAKECMDGOALS)),  $(MAKECMDGOALS),$(subst ., ,$(MAKECMDGOALS)))
partsLength    = $(if $(findstring $(SNAPDIR),$(MAKECMDGOALS)),2,$(words $(targetParts)))
possible_parts = $(if $(findstring $(SNAPDIR),$(MAKECMDGOALS)), ,$(word 3, $(targetParts)) $(word 2, $(targetParts)))

ifeq (release,$(MAKECMDGOALS))
GOAL = image
else
GOAL = $(if $(findstring $(SNAPDIR),$(MAKECMDGOALS)),$(MAKECMDGOALS),$(word 1, $(targetParts)))
endif

CHECK_SOURCES        := $(PROJECTDIR)/build/gn/utils/compare_setup_build_targets.sh
SETUP_TARGET         := $(OUTPUTDIR)/.previous_target_file
.PHONY: check_target
check_target:
	@$(CHECK_SOURCES) --current_target=$(TARGET) --manifest=$(MANIFEST) --previous_target_file=$(SETUP_TARGET)

.PHONY: image-virt
image-virt: setup-virt;

.PHONY: image
image: need_target need_manifest check_target;

.PHONY: run_gn
run_gn: $(GN)
	@$(release_names) PLATFORM_ROOT=$(CURDIR) $(GN) gen ${GN_OUTPUTDIR} $(GN_ARGS)
	@sed -i'' 's/..\/..\/out\//..\//g' ${GN_OUTPUTDIR}/toolchain.ninja
	@if [ $(CACHE) -eq 1 ] ; then \
		$(foreach snap,$(SNAPS), mkdir -p $(GN_GEN_DIR)/$(snap); touch $(GN_GEN_DIR)/$(snap)/$(notdir $(snap)).stamp;) \
	fi

###### Format targets #######
FORMAT_IMAGE  := $(DOCKER_DIR)/id.docker.format
DOCKER_FILE_FORMAT := $(DOCKER_DIR)/Dockerfile.format
$(FORMAT_IMAGE): $(DOCKER_FILE_FORMAT)
	@docker build -f $(DOCKER_FILE_FORMAT) --tag format $(PROJECTDIR)/build $(DOCKER_VERBOSE)
	@docker image ls -q format > $@

format: $(FORMAT_IMAGE)
	@printf "$(YELLOW)Start cleaning $(MAKECMDGOALS)$(NORMAL)\n"
	@date +'%s' > "$(start)"
	@docker run --rm -i$(DOCKER_TTY) -w /platform \
			-v $(CURDIR):/platform:rw \
			--env PLATFORM_ROOT=/platform \
			${DOCKER_USER_ARGS} \
			$(shell cat $(FORMAT_IMAGE) ) \
			$(FORMAT_SCRIPT) --formatter=$(FORMATTER)
	@printf "$(YELLOW)Total Docker execution time: $(GREEN)$(elapsedTime)$(NORMAL)\n"
	@rm "$(start)"

.PHONY: format-gn
format-gn: $(GN)
	@find . -maxdepth 5 \( -iname \*.gn -o -iname \*.gni \) ! -path "./external/*" -exec $(GN) format {} \;

.PHONY: run_docker
run_docker: $(DOCKER_ID) run_gn
	@printf "$(YELLOW)Start running docker$(NORMAL)\n"
	@date +'%s' > "$(start)"
	@docker run --rm -i$(DOCKER_TTY) -w /platform \
		-v $(CURDIR):/platform:rw \
		-v $(TOOLCHAINDIR):$(DOCKER_TOOLCHAINDIR):rw \
		-v $(BSPDIR):$(DOCKER_BSPDIR):rw \
		${DOCKER_USER_ARGS} \
		$(foreach var,$(CURRENT_BUILD_ENV_VAR), --env $(var)) \
		$(foreach var,$(release_names), --env $(var)) \
		$(shell cat $(DOCKER_ID) ) \
		ninja -C /platform/out/gn $(GOAL) $(NINJA_VERBOSE) $(NINJA_SKIP_CHECK)
	@printf "$(YELLOW)Total Docker execution time: $(GREEN)$(elapsedTime)$(NORMAL)\n"
	@rm "$(start)"

.PHONY: run_host
run_host: run_gn
	@if [ ! -d $(SUBMODULEDIR)/env/bin ] ; then \
		printf "$(RED)Please make sure that you configure your system for running build on host.\n \
		All configuration steps are desribed in build/host/README.md $(NORMAL)\n" && false; \
	fi
	@printf "$(YELLOW)Start running host session$(NORMAL)\n"
	@date +'%s' > "$(start)"
	@env -i $(CURRENT_BUILD_ENV_VAR) $(release_names)\
		ninja -C $(CURDIR)/out/gn $(GOAL) $(NINJA_VERBOSE) $(NINJA_SKIP_CHECK)
	@printf "$(YELLOW)Total build execution time: $(GREEN)$(elapsedTime)$(NORMAL)\n"
	@rm "$(start)"

.PHONY: find-cache
find-cache:
ifeq (1, $(CACHE))
	$(eval CACHE_APPS="$(shell $(CACHE_HANDLER) -t $(TARGET) -m $(MANIFEST) -b $(CACHE_BRANCH) -i $(DISTRIBUTION_TYPE) -c $(CACHE_CONFIG))")
endif

.PHONY: release
release: need_target setup find-cache image
	@$(CHECKOUT_JSON_HANDLER) --verbose $(VERBOSE) --manifest $(MANIFEST) --json_response $(JSON_RESPONSE) --target $(TARGET)

.PHONY: release-%
release-%:

.PHONY: version-string
version-string: need_manifest need_target;

### Repack firmware with ViziOS
REPACK_HANDLER := build/scripts/repack/RepackManager.py

FW_ID ?= ""
OVERLAY ?= ""
MG ?= ""

.PHONY: repack
repack:
	@$(startTiming)
	@$(REPACK_HANDLER) --vizios_id $(VIZIOS_ID) \
			--fw_id $(FW_ID) --overlay $(OVERLAY) \
			--id_index $(ID_INDEX) --mg $(MG) \
			--jenkins_token_file $(JENKINS_TOKEN_FILE) \
			--verbose $(VERBOSE) 
	@$(stopTiming)

$(DOCKER_FILE_FORMAT) $(DOCKER_FILE):
	@printf "$(RED)Dockerfile isn't exist, it needed to be setup$(NORMAL)\n"
	@$(MAKE) setup-docker

CLEAN_TARGET := purge clean clean-dlm clean-target clean-apps clean-out $(addprefix clean-,$(notdir $(SNAPS)))
$(CLEAN_TARGET) : $(CLEAN)

CLEAN_IMAGE  := $(DOCKER_DIR)/id.docker.$(DOCKER_BASE_TAG)
ifeq (github, $(CONTAINER_RUNNER))
.PHONY: $(CLEAN_IMAGE)
endif

$(CLEAN_IMAGE):
	@printf "FROM ubuntu:focal as clean-base\nRUN apt-get update && apt-get install --yes make ninja-build" | \
	 docker build -f - --target clean-base --tag $(DOCKER_BASE_TAG) $(PROJECTDIR)/build $(DOCKER_VERBOSE)
	@docker image ls -q $(DOCKER_BASE_TAG) > $@

clean_docker_mode: $(CLEAN_IMAGE) run_gn
	@$(startTiming)
	@docker run --rm -i$(DOCKER_TTY) -w /platform \
			-v $(CURDIR):/platform:rw \
			--env PLATFORM_ROOT=/platform \
			$(shell cat $(CLEAN_IMAGE) ) \
			bash -c "ninja -C /platform/out/gn $(GOAL) $(NINJA_VERBOSE); \
			         chown -R $(UID):$(GID) \$${PLATFORM_ROOT}/out"
	@$(stopTiming)

clean_host_mode: run_gn
	@$(startTiming)
	@env -i PLATFORM_ROOT=$(PROJECTDIR) \
			ninja -C $(PROJECTDIR)/out/gn $(GOAL) $(NINJA_VERBOSE)
	$(stopTiming)

ifeq (, $(ONLINE_MODE))
$(DOCKER_ID): $(DOCKER_FILE)
	@$(startTiming)
	@printf "$(YELLOW)Building Docker image$(NORMAL)\n"
	@if [ ! -z `docker image ls -q $(DOCKER_TAG)` ] ; then \
		printf "$(YELLOW)A docker image with the same tag already exists. The tag of the older docker image will be dropped.$(NORMAL)\n"; \
	fi
	@docker build -f $(DOCKER_FILE) --tag $(DOCKER_TAG) $(PROJECTDIR)/build $(DOCKER_VERBOSE) || \
		(printf "$(RED)ERROR: Failed to build docker image!$(NORMAL)\n" && \
		 printf "$(YELLOW) Try to exec: \"docker pull ubuntu:focal\" and rerun make again.\n$(NORMAL)" && \
		 printf "$(YELLOW) Please check the ViziOS Build System confluence page or ask ViziOS maintainers if previous command does not help.\n$(NORMAL)" && \
		 false)
	@docker image ls -q $(DOCKER_TAG) > $@
	@$(stopTiming)
else
.PHONY: $(DOCKER_ID)
$(DOCKER_ID):
	@$(startTiming)
	$(eval DOCKER_MANIFEST_SHA = $(shell cat $(MANIFEST) | jq -r '.submodules.default[] | select (.path=="build/docker")."commit" '| cut -c1-8))
	$(eval DOCKER_IMAGE_TAR = $(DOCKER_DIR)/platform-$(CONTAINER_RUNNER)-$(DOCKER_MANIFEST_SHA).tar.gz)
	$(eval DOCKER_TAG=$(DOCKER_TAG)-$(DOCKER_MANIFEST_SHA))
	@if [ -z `docker image ls -q $(DOCKER_TAG)` ] ; then \
		printf "$(YELLOW)Preparing Docker image$(NORMAL)\n"; \
		$(DOCKER_HANDLER) --image_tar $(DOCKER_IMAGE_TAR) --docker_tag $(DOCKER_TAG) --runner $(CONTAINER_RUNNER) --commit_hash $(DOCKER_MANIFEST_SHA); \
	fi
	@docker image ls -q $(DOCKER_TAG) > $@;
	@$(stopTiming);
endif

.PHONY: build_docker
build_docker: $(DOCKER_ID)

.PHONY: test
test:

.PHONY: run_docker_for_test
run_docker_for_test: $(DOCKER_ID)
	@docker run -it -w /platform -v $(CURDIR):/platform:rw $(shell cat $(DOCKER_ID)) bash


### CLEAN TARGETS THAT DON'T REQUIRE A DOCKER CONTAINER
.PHONY: clean-manifest
clean-manifest: run_gn
	@PLATFORM_ROOT=$(CURDIR) \
	ninja -C ${GN_OUTPUTDIR} clean-manifest $(NINJA_VERBOSE)

### HELP TARGETS

.PHONY: help-%
help-%: run_gn
	@PLATFORM_ROOT=$(CURDIR) \
	 ninja -C ${GN_OUTPUTDIR} $@ $(NINJA_VERBOSE)

define HELP_TEXT
Welcome to the ViziOS platform firmware builder.

Available Targets:
   [SNAP]                 - Build a single snap (from the list below)
   [SNAP].[PART].[OP]     - Perform OP on just a single part of the snapcraft recipe OP can be:
                               'pull', 'build', 'stage', 'prime', or 'clean'
   setup                  - Pull all 'default' modules listed in the platform-manifest and update them to the
                               specified commit.
   setup <TARGET>         - Pull all 'default' and 'target' modules listed in the platform-manifest and update them to the
                               specified commit, 'target' one is priority.
   setup-[SNAP]           - Pull all snap dependency module listed in the platform-manifest and update them to the
                               specified commit.
   setup-tools            - Pull all 'tools' modules ('gcc', 'gdb', and 'valgrind') listed in the platform-manifest.
   image <TARGET>         - Generate the ViziOS tarballs for firmware repack and OTA updates
                            NOTE: Please, make sure that you have right sources for <TARGET>
                                  You need to do "make setup TARGET=<TARGET>" before
   release <TARGET>       - A shortcut for 'make setup' followed by 'make image'
   release-<SNAP>         - Build a snap and perform all pre-release activities
   help                   - Display this notice [DEFAULT]
   help-[SNAP]            - Display a help message of a particular snap
   purge                  - Clean all snaps, out directory and external sources
   clean                  - Clean all snaps
   clean-out              - Clean 'out' directory
   clean-target           - Clean all targets which are depend on TARGET or sysroot-vizio
   clean-dlm              - Clean all targets which are depend on DISTRIBUTION_TYPE or sysroot-dlm
   clean-apps             - Clean all apps directory and snaps in 'out' directory with 'vizio-app' in name.
   clean-[SNAP]           - Clean a particular snap, where possible SNAP values are below
   clean-manifest         - Removes the default manifest
   format                 - Run clang-format on ViziOS code. To set a specific directory in ViziOS use FORMATTER macro
   version-string         - Display the version for release target.  The TARGET and build_release
                               variables need to be defined.

Variables that can influence build behavior (make VARIABLE=VALUE target):
   TARGET=<TARGET>        - set target
   BSP=1                  - enable building the BSP package
   DEV=1                  - enable debug build

   VERBOSE=sync           - Build in one stream, all logs prints as stream
   VERBOSE=async          - Parallel build, all logs prints buffered
   VERBOSE=quiet          - Parallel build, no internall logs from snapcraft

   BSPDIR=<PATH>          - Override the location that is used to search for the BSP package.
                               Default:
                               $(BSPDIR)
   MTK_CONFIG=<path>      - Override the location that is used to search for the mtk_config file.
                               Default:
                               $(APOLLO_SUPPORT_DIR)/config/mtk_config.json
   MTK_BRANCH=<ID>        - Override the defualt branch mention in mtk_config file.
   MTK_TARGET=<TARGET>    - Override the defualt target mention in mtk_config file.
   REMOTE_SERVER=<REMOTE> - select remote server 'vizio' or 'mtk'.
   TOOLCHAINDIR=<PATH>    - Override the location that is used to search for the firmware toolchain.
                               Default:
                               /opt/toolchain
   MANIFEST=<PATH>        - Override the location that is used to search for the manifest.json file.
                               Default:
                               $(OUTPUTDIR)/platform-manifest/manifest.json
   NO_TTY=1               - Disables running the docker container with the -t flag
   JSON_RESPONSE=1        - Enable writing submodules info to:
                               $(OUTPUTJSON)
   platform-manifest=<ID> - Checkout platform-manifest repo to <ID> value
   platform=<ID>          - Checkout platform repo to <ID> value
   ONLINE_MODE            - Download docker image from Artifactory instead building from Dockerfile

   build_release=<BUILD_RELEASE>
                          - Set release type
   CACHE=1                - To Use cache app from the atrifactory
   CACHE_BRANCH=<BRANCH>  - To Use as cache branch from the atrifactory
   CACHE_CONFIG=<path>    - Override the location that is used to search for the cache_config file.
                               Default:
                               $(CACHE_SUPPORT_DIR)/config/cache_config.json

    NO_STRIP=0             - strip all snaps which goes into image (DEFAULT)
    NO_STRIP=1             - don't strip any package which goes into image (could produce problems with rootfs)
    NO_STRIP=<snap_name..> - disable strip for csv list of snaps

   CONTAINER_RUNNER=<CONTAINER_RUNNER>
                          - Set runner for your container. It can be: main, github
                          NOTE: Default value is 'docker', 'github' is used only in github actions
    HOST=1                - Run build on host machine instead of docker container.
                          NOTE: Developer has to configure environment on his machine manually.
                                Users of LinuxOS can use build/host/setup_environment.sh script with superusers permitions:
                                sudo ./build/host/setup_environment.sh script--PLATFORM_ROOT=$(CURDIR)
                                Another user can find information about setup in build/host/README.md

Available <TARGET> Options:
    virt                  - build snap packages for emulator
    mtk5581               - build snap packages for MTK 5581
    mtk5597               - build snap packages for MTK 5597
    mtk5583               - build snap packages for MTK 5583
    mtk5691               - build snap packages for MTK 5691
    mtk5695               - build snap packages for MTK 5695
    mtk5695l              - build snap packages for MTK 5695L
    mtk5695s              - build snap packages for MTK 5695S
    nt72690               - build snap packages for NVT 72690

Available <BUILD_RELEASE> Options:
    dev
    qa
    prod

Available Snaps:
endef

.PHONY: help
help:
	@$(info $(HELP_TEXT))
	@echo "$(notdir $(SNAPS))" | sed -e 's/[ ]*\([^ ]\+\)/   \1\n/g'
